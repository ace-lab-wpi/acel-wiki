{
    "docs": [
        {
            "location": "/", 
            "text": "Development Guide \nfor dRonin\n\n\n\nAbout\n\n\nWelcome to the dRonin documentation.\n\n\nThis guide is intended for developers. If you just want to lean how to setup and use the dRonin software, please refer to \nthis\n.\n\n\nSetup\n\n\n1. \nDevelopment Setup: Linux\n\n\nArchitecture\n\n\n1. \nOverview\n\n\nContribute\n\n\nLicense\n\n\nThis documentation is \u00a9 Copyright 2016 dRonin. The license for this documentation is presently being determined; in the meantime, you are free to copy it for personal use.", 
            "title": "Home"
        }, 
        {
            "location": "/#about", 
            "text": "Welcome to the dRonin documentation.  This guide is intended for developers. If you just want to lean how to setup and use the dRonin software, please refer to  this .", 
            "title": "About"
        }, 
        {
            "location": "/#setup", 
            "text": "", 
            "title": "Setup"
        }, 
        {
            "location": "/#1-development-setup-linux", 
            "text": "", 
            "title": "1. Development Setup: Linux"
        }, 
        {
            "location": "/#architecture", 
            "text": "", 
            "title": "Architecture"
        }, 
        {
            "location": "/#1-overview", 
            "text": "", 
            "title": "1. Overview"
        }, 
        {
            "location": "/#contribute", 
            "text": "", 
            "title": "Contribute"
        }, 
        {
            "location": "/#license", 
            "text": "This documentation is \u00a9 Copyright 2016 dRonin. The license for this documentation is presently being determined; in the meantime, you are free to copy it for personal use.", 
            "title": "License"
        }, 
        {
            "location": "/setup/linux_setup/", 
            "text": "Development Setup: Linux\n\n\nConsider forking the project on GitHub before proceeding with this procedure if you intend to contribute back to the project. (More details on this are at \nTracking Development with Git\n)\n\n\n1. Set up prerequisites for the build environment\n\n\nUBUNTU/MINT/DEBIAN BASED DISTRIBUTIONS\n\n\nFirst ensure your package manager is up to date:\n\n\nsudo apt-get update\n\n\n\n\nNext, get a host compiler and other build tools, along with your revision control environment:\n\n\nsudo apt-get install build-essential gdb wget debhelper ccache git\n\n\n\n\nIf you are running a 64-bit version of Linux (if you run uname -m and the output says x86_64 you are in a 64-bit environment), you'll also need to install 32-bit compatibility libraries.\n\n\nsudo apt-get install gcc-multilib\n\n\n\n\nFinally, install some additional libraries required to compile GCS\n\n\nsudo apt-get install zlib1g-dev libusb-1.0-0-dev libudev-dev libgl1-mesa-dev\n\n\n\n\nFEDORA-BASED DISTRIBUTIONS\n\n\nInstall the required packages:\n\n\nsudo dnf install libstdc++.i686 gcc-c++ ccache\nsudo dnf install libusb-devel qt5-qtdeclarative-devel qt5-qtimageformats qt5-qtserialport-devel qt5-qtsvg-devel qt5-qtxmlpatterns-devel SDL-devel systemd-devel zlib-devel\n\n\n\n\n2. Check out the dRonin repository and build\n\n\nCLONE THE SOURCE CODE REPOSITORY\n\n\nFirst, clone the dRonin repository. Change to an appropriate directory to check out the code. If you have your own fork, specify its URL on the git command line (otherwise you can use the parent fork per the below example).\n\n\ngit clone git://github.com/d-ronin/dRonin.git\ncd dRonin\n\n\n\n\nAUTOMATIC DOWNLOAD AND INSTALL OF REQUIRED PROGRAMS\n\n\nThe dRonin build environment is capable of installing the rest of the tools that it needs.\n\n\nQt build tools\nNext, run make qt_sdk_install, copy the path from the output in your terminal and paste it into the installer when prompted.\n\n\n Do not install Qt to the default location!\n\nWhen running the qt sdk install command, you'll be told where to install qt, then the GUI installer will open. Here is what it will look like:\n\n*** NOTE NOTE NOTE ***\n*\n*  In the GUI, please use exactly this path as the installation path:\n*        /some/path/src/dRonin/tools/Qt5.5.1\n*\n*** NOTE NOTE NOTE ***\nBe sure to copy the specified path into the installer when prompted for the install location!\n\n\n\n\nArm cross compilation toolchain\nThis is easy. Just type: make arm_sdk_install\n\n\n3. Build the software\n\n\nYou should be ready to go. Type make all to compile the entire project. Type make to see a list of possible make arguments.\n\n\n4. Install udev rules\n\n\nYou need to grant permission for normal users (ie. not root) to access your flight-controller boards from the GCS. This is accomplished by installing specific udev rules for the various flight controller boards.\n\n\nCheck if your user is in the group \"plugdev\" by running 'groups'\n\n\nIf you're not in group \"plugdev\"...\n\n\nIf you're not in the group \"plugdev\", you can add the group to your user by running this command:\n\n\nsudo usermod -a -G plugdev user\n\n\n\n\nThen, log-out and log back in and check again by running groups\n\n\nNext, run these commands to install the dRonin udev rules:\n\n\nsudo cp package/linux/deb/_package.udev /etc/udev/rules.d/45-dronin-permissions.rules\nsudo udevadm control --reload-rules\n\n\n\n\n4. Run GCS\n\n\nLaunch the gcs with ./build/ground/gcs/bin/drgcs and connect to / flash your board.", 
            "title": "Linux Setup"
        }, 
        {
            "location": "/setup/linux_setup/#development-setup-linux", 
            "text": "Consider forking the project on GitHub before proceeding with this procedure if you intend to contribute back to the project. (More details on this are at  Tracking Development with Git )", 
            "title": "Development Setup: Linux"
        }, 
        {
            "location": "/setup/linux_setup/#1-set-up-prerequisites-for-the-build-environment", 
            "text": "", 
            "title": "1. Set up prerequisites for the build environment"
        }, 
        {
            "location": "/setup/linux_setup/#ubuntumintdebian-based-distributions", 
            "text": "First ensure your package manager is up to date:  sudo apt-get update  Next, get a host compiler and other build tools, along with your revision control environment:  sudo apt-get install build-essential gdb wget debhelper ccache git  If you are running a 64-bit version of Linux (if you run uname -m and the output says x86_64 you are in a 64-bit environment), you'll also need to install 32-bit compatibility libraries.  sudo apt-get install gcc-multilib  Finally, install some additional libraries required to compile GCS  sudo apt-get install zlib1g-dev libusb-1.0-0-dev libudev-dev libgl1-mesa-dev", 
            "title": "UBUNTU/MINT/DEBIAN BASED DISTRIBUTIONS"
        }, 
        {
            "location": "/setup/linux_setup/#fedora-based-distributions", 
            "text": "Install the required packages:  sudo dnf install libstdc++.i686 gcc-c++ ccache\nsudo dnf install libusb-devel qt5-qtdeclarative-devel qt5-qtimageformats qt5-qtserialport-devel qt5-qtsvg-devel qt5-qtxmlpatterns-devel SDL-devel systemd-devel zlib-devel", 
            "title": "FEDORA-BASED DISTRIBUTIONS"
        }, 
        {
            "location": "/setup/linux_setup/#2-check-out-the-dronin-repository-and-build", 
            "text": "", 
            "title": "2. Check out the dRonin repository and build"
        }, 
        {
            "location": "/setup/linux_setup/#clone-the-source-code-repository", 
            "text": "First, clone the dRonin repository. Change to an appropriate directory to check out the code. If you have your own fork, specify its URL on the git command line (otherwise you can use the parent fork per the below example).  git clone git://github.com/d-ronin/dRonin.git\ncd dRonin", 
            "title": "CLONE THE SOURCE CODE REPOSITORY"
        }, 
        {
            "location": "/setup/linux_setup/#automatic-download-and-install-of-required-programs", 
            "text": "The dRonin build environment is capable of installing the rest of the tools that it needs.  Qt build tools\nNext, run make qt_sdk_install, copy the path from the output in your terminal and paste it into the installer when prompted.   Do not install Qt to the default location!\n\nWhen running the qt sdk install command, you'll be told where to install qt, then the GUI installer will open. Here is what it will look like:\n\n*** NOTE NOTE NOTE ***\n*\n*  In the GUI, please use exactly this path as the installation path:\n*        /some/path/src/dRonin/tools/Qt5.5.1\n*\n*** NOTE NOTE NOTE ***\nBe sure to copy the specified path into the installer when prompted for the install location!  Arm cross compilation toolchain\nThis is easy. Just type: make arm_sdk_install", 
            "title": "AUTOMATIC DOWNLOAD AND INSTALL OF REQUIRED PROGRAMS"
        }, 
        {
            "location": "/setup/linux_setup/#3-build-the-software", 
            "text": "You should be ready to go. Type make all to compile the entire project. Type make to see a list of possible make arguments.", 
            "title": "3. Build the software"
        }, 
        {
            "location": "/setup/linux_setup/#4-install-udev-rules", 
            "text": "You need to grant permission for normal users (ie. not root) to access your flight-controller boards from the GCS. This is accomplished by installing specific udev rules for the various flight controller boards.  Check if your user is in the group \"plugdev\" by running 'groups'  If you're not in group \"plugdev\"...  If you're not in the group \"plugdev\", you can add the group to your user by running this command:  sudo usermod -a -G plugdev user  Then, log-out and log back in and check again by running groups  Next, run these commands to install the dRonin udev rules:  sudo cp package/linux/deb/_package.udev /etc/udev/rules.d/45-dronin-permissions.rules\nsudo udevadm control --reload-rules", 
            "title": "4. Install udev rules"
        }, 
        {
            "location": "/setup/linux_setup/#4-run-gcs", 
            "text": "Launch the gcs with ./build/ground/gcs/bin/drgcs and connect to / flash your board.", 
            "title": "4. Run GCS"
        }, 
        {
            "location": "/arch/arch_overview/", 
            "text": "Architecture Overview\n\n\nThere are a few core concepts required to understand Tau Labs software, and especially the firmware side.\n\n\nModules\n\n\nflight/Modules\n\n\n[[Modules|Development Modules]] are the core logical units on the firmware side. They are generally fairly compact logical components of the flight software, such as a module to get sensor data, or a module to estimate the attitude. Modules can only communicate either via drivers calls (PiOS) or by getting and setting data via UAVObjects.\n\n\nPiOS\n\n\nflight/PiOS\n\n\nPiOS (Pilot Operating System) is the hardware abstraction layer. It is divided into two main sections. The \nflight/PiOS/STM32Fxx\n sections which are hardware specific (currently only supporting STM32 F1, F3, and F4 series processors).  The \nflight/PiOS/Common\n directory contains drivers that run on all platforms via the hardware specific platforms.  PiOS contains all the [[drivers|Development Drivers]] for external sensor chips, PWM generation and input, PPM, serial communications, etc.\n\n\nUAVObjects\n\n\nshared/uavobjectdefinition\n\n\nDetails on adding a new UAVObject can be found \nhere\n\n\nUAVObjects are the data (and setting) representation used on both the firmware side and the GCS side.  They are implemented as data structures generated dynamically from xml definitions. These data objects are transferred from the firmware side to the ground control side and also used for inter-module communication on the firmware.\n\n\nOn the firmware side these interface via FreeRTOS primitives such as queues. Modules can block on updates from an object, so that when another module performs an update the first module resumes. Based on the meta data for that object, updates may be transferred to the ground control system with different frequencies.\n\n\nThe eventdispatcher ( \nflight/UAVObjects/eventdispatcher\n ) is responsible for performing these updates and handling the FreeRTOS interface as well as storage in the UAVObjectManager ( \nflight/UAVObjects/uavobjectmanager\n ).  The telemetry module performs the updates to the ground control system ( \nflight/Modules/Telemetry/telemetry\n ).\n\n\nUAVTalk\n\n\nflight/UAVTalk\n\n\n[[UAVTalk|Development UAVTalk Protocol]] is the protocol used to serialize UAVObjects, as well as send updates or request updates.", 
            "title": "Architecture Overview"
        }, 
        {
            "location": "/arch/arch_overview/#architecture-overview", 
            "text": "There are a few core concepts required to understand Tau Labs software, and especially the firmware side.", 
            "title": "Architecture Overview"
        }, 
        {
            "location": "/arch/arch_overview/#modules", 
            "text": "flight/Modules  [[Modules|Development Modules]] are the core logical units on the firmware side. They are generally fairly compact logical components of the flight software, such as a module to get sensor data, or a module to estimate the attitude. Modules can only communicate either via drivers calls (PiOS) or by getting and setting data via UAVObjects.", 
            "title": "Modules"
        }, 
        {
            "location": "/arch/arch_overview/#pios", 
            "text": "flight/PiOS  PiOS (Pilot Operating System) is the hardware abstraction layer. It is divided into two main sections. The  flight/PiOS/STM32Fxx  sections which are hardware specific (currently only supporting STM32 F1, F3, and F4 series processors).  The  flight/PiOS/Common  directory contains drivers that run on all platforms via the hardware specific platforms.  PiOS contains all the [[drivers|Development Drivers]] for external sensor chips, PWM generation and input, PPM, serial communications, etc.", 
            "title": "PiOS"
        }, 
        {
            "location": "/arch/arch_overview/#uavobjects", 
            "text": "shared/uavobjectdefinition  Details on adding a new UAVObject can be found  here  UAVObjects are the data (and setting) representation used on both the firmware side and the GCS side.  They are implemented as data structures generated dynamically from xml definitions. These data objects are transferred from the firmware side to the ground control side and also used for inter-module communication on the firmware.  On the firmware side these interface via FreeRTOS primitives such as queues. Modules can block on updates from an object, so that when another module performs an update the first module resumes. Based on the meta data for that object, updates may be transferred to the ground control system with different frequencies.  The eventdispatcher (  flight/UAVObjects/eventdispatcher  ) is responsible for performing these updates and handling the FreeRTOS interface as well as storage in the UAVObjectManager (  flight/UAVObjects/uavobjectmanager  ).  The telemetry module performs the updates to the ground control system (  flight/Modules/Telemetry/telemetry  ).", 
            "title": "UAVObjects"
        }, 
        {
            "location": "/arch/arch_overview/#uavtalk", 
            "text": "flight/UAVTalk  [[UAVTalk|Development UAVTalk Protocol]] is the protocol used to serialize UAVObjects, as well as send updates or request updates.", 
            "title": "UAVTalk"
        }, 
        {
            "location": "/tutorials/test/", 
            "text": "", 
            "title": "TestPage"
        }
    ]
}